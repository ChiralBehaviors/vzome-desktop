// the buildscript closure has to be declared before the plugins closure
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'edu.sc.seis.gradle:launch4j:1.0.6'
    }
}

// launch4j is not a Gradle Core plugin, 
// so it can't be declared with the plugins { } syntax,
// but it still works using the "apply plugin:" syntax
apply plugin: 'launch4j' 

dependencies {
    compile project( ':' )
}

// TODO: By default, this subproject creates windows-5.0.jar based on the name of the subproject. 
// windows-5.0.jar is not intended to be generated by this project 
// so I want to eventually figure out how to disable generation of it 
// and to avoid distributing it since it's just unnecessary overhead.

// used by launch4j and jre bundling tasks
// The companyName element of versionInfo is supported by launch4j, but not (yet) by the plugin.
ext.companyName = 'Scott Vorthmann'
ext.copyright = "Copyright ${Calendar.getInstance().get(Calendar.YEAR)}, ${companyName}"	// year that generateXmlConfig task is run
ext.l4jxmlFileName = 'launch4j.xml'
ext.l4jOutputDir = 'launch4j/windows'		// path is relative to buildDir
ext.l4jOutputBaseFileName = "${rootProject.appName}-Windows-x64-${version}"
ext.bundledJrePath = './jre/'				// path is relative to launch4j.outputDir and must start with '.'

// JRE version naming convention based on Oracle's Java version naming convention (e.g. 1.8.0_45)
ext.jreRevision = 0

// *** THIS IS WHERE THE BUNDLED JRE TARGET VERSION IS CONTROLLED ***
// 31 = Oracle
// 40 = Azul			// TODO: Manually repackage the "jre" folder and the "release" file for 40 (Azul) as described in README.md
// 45 = Oracle
ext.jreBuildNumber = 45 // Default is the latest Oracle JRE

// allow ext.jreBuildNumber to be overridden by the gradle command line 
// e.g. gradle createExe -PjreBuildOverride=45
//   or gradle distSfx -PjreBuildOverride=45
//   or gradle extraProperties -PjreBuildOverride=45
if( project.hasProperty( 'jreBuildOverride' ) ) {
	project.jreBuildNumber = Integer.parseInt( jreBuildOverride )
}

ext.jreTargetVersion = "${targetCompatibility}.${jreRevision}_${jreBuildNumber}"   // target JRE version   (e.g. 1.8.0_45)
ext.jrePriorVersion  = "${targetCompatibility}.${jreRevision}_${jreBuildNumber-1}" // target JRE version-1 (e.g. 1.8.0_44)
// these are used by the zip and distribution tasks after launch4j has run
ext.jreArchiveSourcePath = 'jre/x64/'		// path is relative to the root of this subproject
ext.jreDistributionPath = "$l4jOutputDir/$bundledJrePath"
ext.win64InstallerBaseFileName = "extract-${rootProject.appName}-Windows-x64"

launch4j {
	xmlFileName = project.l4jxmlFileName
	mainClassName = project.mainClassName
	outputDir = project.l4jOutputDir
	outfile = "${l4jOutputBaseFileName}.exe"
	jar = 'lib/' + project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files.getSingleFile().name	// path is relative to outputDir
	icon = '../../../platform/windows/resources/icons/vZomeLogo.ico'	// path is relative to outputDir
	jreMinVersion = project.jrePriorVersion
	jreMaxVersion = project.jreTargetVersion
	bundledJrePath = project.bundledJrePath	// path is relative to launch4j.outputDir

	opt = '-Xmx3048M'
	// most of the rootProject.jvmArgs have apple or macos in the name, but I'm going to include all of them anyway for now...
	rootProject.jvmArgs.each { entry ->
		opt = opt + " -D${entry.key}=${entry.value}"
	}
	cmdLine = ''  // docs say cmdLine is boolean, but code says it's a String just as we'd expect.
	def sp = ''
	rootProject.vzomeArgs.each { entry ->
		cmdLine = cmdLine + "${sp}${entry}"
		sp = ' '
	}

	// The companyName element of versionInfo is supported by launch4j, but not (yet) by the plugin.
	//companyName = project.companyName 
	version = project.version
	copyright = project.copyright

	// TODO: Lots of the config file parameters are not supported by the launch4j plugin
	// so eventually, it may be better to store a copy of launch4j.xml in the project 
	// and then overload the generateXmlConfig task to just copy it into the outputDir
	// or just completely override the generateXmlConfig task.
	// The problem with a static config file in the project is that it wouldn't automatically pick up the dependencies.

	// TODO: fileDescription, productName and internalName elements of versionInfo are hard-coded in the plugin to use project.name
	// On 5/12/2015, I posted a feature request at https://code.google.com/p/gradle-launch4j/wiki/Intro
	//  to let these three properties be configurable in the plugin.
	// Eventually, once the plugin supports them, I want them to use these values:
	//fileDescription = 'Generates 3D zome models'
	//productName = rootProject.name
	//internalName = rootProject.name
}

// msg is only displayed if the gradle logging level is set with command line parameter '--info' or '--debug'
// so use logInfo instead of println
def logInfo(msg) {
	getLogger().info msg
}

task cleanJre {
	outputs.upToDateWhen {
		return !( new File(project.jreDistributionPath).exists() );
	}
    doLast() {
		delete project.jreDistributionPath
		logInfo "Deleting JRE distribution directory: ${jreDistributionPath}"
    }
	group = 'Build'
	description = "Removes the JRE distribution directory."
}
// This dependency is not really needed as long as jreDistributionPath is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanJre

task cleanDistributions {
	def folder = "${buildDir}/distributions"
	outputs.upToDateWhen {
		return !( new File(folder).exists() );
	}
    doLast() {
		delete folder
		logInfo "Deleting installer distribution directory: ${folder}"
    }
	group = 'Build'
	description = "Removes the installer distribution directory."
}
// This dependency is not really needed as long as folder is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanDistributions

task extractWin64Jre(type: Sync) {
	def src = "${jreArchiveSourcePath}jre${jreTargetVersion}.zip"
	def dst = "${buildDir}/${jreDistributionPath}"
    from zipTree(src)
	into dst
	doLast() {
		if(getDidWork()) {
			logInfo "Extracting JRE from $src into $dst"
		}
	}
	group = 'Windows Distribution'
	description = "Unzips the Windows 64-bit JRE from ${src} into the bundled JRE path."
}

task zipWin64Distribution(type: Zip) {
	def src = "${buildDir}/${l4jOutputDir}"
	from src
		exclude "${launch4j.xmlFileName}"
	baseName = win64InstallerBaseFileName
	// TODO: We'll eventually want to not include the jre version in the installer distribution. 
	// Here's where that gets changed.
	//classifier = "x64-jre${jreTargetVersion}"
	//classifier = 'x64'

	doLast() {
		if(getDidWork()) {
			logInfo "Zipping ${src}\n   into ${archivePath}"
		}
	}
	group = 'Windows Distribution'
	description = 'Generates the 64-bit Windows zip file distribution.'
	dependsOn { [ "createExe", "extractWin64Jre" ] }
}

task createWin64sfxInstaller(type: FileConcatTask) {
	// First source file MUST be unzipsfx-x64.exe which is extracted directly from unzipsfx.zip.
	// Second source file is the output of zipWin64Distribution
	// Note that the zipTree call is wrapped in closure so that configuration is only resolved at execution time.
	source = files(
		( { zipTree('../../platform/windows/tools/unzipsfx/unzipsfx.zip').matching { include 'unzipsfx-x64.exe' } } ), 
		"${zipWin64Distribution.archivePath}"
	)
	destination = "${zipWin64Distribution.archivePath}".replace('.zip', '.exe')
	doLast() {
		println "Generated ${getDestination()}"
	}
	
	group = 'Windows Distribution'
	description = 'Generates the 64-bit Windows self-extracting installer.'
	dependsOn zipWin64Distribution
}

task distSfx {
	group = 'Windows Distribution'
	description = 'Primary task to be invoked for creating the self-extracting installer with launch4j and subsequent build steps.'
	dependsOn createWin64sfxInstaller
}

class FileConcatTask extends SourceTask {
    private destination
    @OutputFile File getDestination() { project.file(destination) }
    void setDestination(destination) { this.destination = destination }

    @TaskAction
    void doBinaryFileConcat() {
		logInfo 'Concatenating:'
		getDestination().withOutputStream { out ->
			getSource().files.each {
				logInfo("  +-<<--- ${it.name}")
                it.withInputStream { out << it }
            }
        }
		logInfo '  |'
		logInfo "  +--->>> ${getDestination()}"
    }
	
	public void logInfo(String msg) {
		getLogger().info(msg)
	}
}

// extra properties of subprojects are not shown if this task is moved to the root project.
task extraProperties {
	doLast {
		for(Project proj : rootProject.getAllprojects()) {
			if(!proj.ext.properties.isEmpty()) {
				println "[${proj.name}] extra properties:"
				proj.ext.properties.sort( { it.key } ).each { entry ->
					println "    $entry.key = $entry.value"
				}
			}
		}
	}
	group = 'Help'
	description = "Displays the 'extra' properties of the [${project.name}] project and its parent project(s)."
}
